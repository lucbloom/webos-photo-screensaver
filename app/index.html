<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>LG webOS Slideshow</title>
	<style>
	html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
	#app{position:relative;height:100%;width:100%;overflow:hidden;background:#000}

	.layer{
		position:absolute;
		inset:0;
		background-size:cover;
		background-position:center center;
		background-repeat:no-repeat;
		opacity:0;
		transition:opacity 800ms ease;
	}
	.layer.visible{opacity:1}

	#controls{position:absolute;left:12px;top:12px;z-index:40}
	#msg{position:absolute;left:12px;bottom:12px;z-index:40;background:rgba(0,0,0,0.5);padding:8px 12px;border-radius:6px}

	#settings{
		position:absolute;
		left:50%;
		top:50%;
		transform:translate(-50%,-50%);
		z-index:50;
		background:rgba(10,10,10,0.95);
		border-radius:10px;
		min-width: 540px;
		padding: 28px;
		font-size: 18px;
		box-shadow:0 6px 24px rgba(0,0,0,0.6);
	}
	#settings.hidden{display:none}
	#settings h2{margin:0 0 8px 0;font-size:18px}
	.setting-row{display:flex;align-items:center;margin:8px 0;gap:8px}
	.setting-row label{width:130px;color:#ccc;font-size:14px}
	.setting-row input{flex:1;padding:8px;border-radius:6px;border:1px solid #333;background:#111;color:#fff}
	#settings .note{color:#f55;margin-bottom:6px}
	#settings button{padding:8px 12px;border-radius:6px;border:0;background:#2b7cff;color:#fff;cursor:pointer}

	#pauseOverlay{position:absolute;left:50%;top:20%;transform:translateX(-50%);z-index:60;font-size:96px;display:none;pointer-events:none}
	#pauseOverlay.visible{display:block}

	#loadingSpinner{position:absolute;left:50%;top:60%;transform:translate(-50%,-50%);z-index:60;display:none}
	#loadingSpinner.visible{display:block}

	/* hint hidden by default; shown only when paused */
	#hint{
		position:absolute;
		right: 50%;
		transform: translateX(50%);
		bottom:12px;
		z-index:40;
		font-size:13px;
		opacity:0.8;
		display:none;
		position: absolute;
		text-align: center;
	}
	input:focus{outline:2px solid rgba(100,150,255,0.6)}
	button{font-size:16px}
	@media (max-width:600px){#settings{min-width:90%}}
	#UI {
		position: fixed;       /* stay on screen even when scrolling */
		inset: 0;              /* top:0; right:0; bottom:0; left:0 */
		width: 100%;
		height: 100%;
		transition: opacity 0.5s ease;
		opacity: 0;
		pointer-events: none;
	}
	#UI.visible {
		opacity: 1;
		pointer-events: auto;
	}
	/* feedback buttons */
	#feedbackBtns {
		position: absolute;
		bottom: 2%;
		right: 2%;
		z-index: 50;
		display: flex;
		gap: 10px;
		pointer-events: auto;
	}
	#feedbackBtns button {
		background: rgba(0.8,0.4,0.4,0.5);
		border: none;
		color: white;
		cursor: pointer;
		padding: 2px 4px 10px 10px;
		border-radius: 14px;
		font-size: 64px;
	}
	
	.navBtn {
		position: absolute;
		top: 50%;
		transform: translateY(-50%);
		width: 60px;
		height: 120px;
		background: rgba(0,0,0,0.3);
		color: white;
		font-size: 48px;
		text-align: center;
		line-height: 120px;
		border-radius: 8px;
		cursor: pointer;
		user-select: none;
		pointer-events: auto;
	}

	#leftBtn { left: 12px; }
	#rightBtn { right: 12px; }
	</style>
</head>
<body>
	<div id="app" tabindex="0">
		<div id="layerA" class="layer"></div>
		<div id="layerB" class="layer"></div>
		
		<div id="pauseOverlay">‚è∏</div>
		<div id="loadingSpinner">Loading‚Ä¶</div>

		<div id="settings" class="hidden" role="dialog" aria-modal="true">
			<h2>Slideshow settings</h2>
			<div id="serverError" class="note" style="display:none">Server not responding</div>
			<div class="setting-row">
				<label for="ipInput">Server IP</label>
				<input id="ipInput" type="text" placeholder="192.168.2.33" />
			</div>
			<div class="setting-row">
				<label for="portInput">Server Port</label>
				<input id="portInput" type="text" placeholder="8001" />
			</div>
			<div class="setting-row">
				<label for="delayInput">Delay (seconds)</label>
				<input id="delayInput" type="number" min="1" step="1" placeholder="Delay in seconds" />
			</div>
			<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
				<button id="cancelBtn">Cancel</button>
				<button id="saveBtn">Start</button>
			</div>
		</div>

		<div id="msg" aria-live="polite"></div>
		<div id="hint">‚Üê previous/next ‚Üí<br>OK: pause/settings<br>BACK: exit</div>
		<div id="UI">
			<div id="leftBtn" class="navBtn">‚Äπ</div>
			<div id="rightBtn" class="navBtn">‚Ä∫</div>
			<div id="feedbackBtns">
				<button id="likeBtn">‚ù§Ô∏è</button>
				<button id="excludeBtn">üëé</button>
				<button id="rotateBtn">‚Üª</button>
			</div>
		</div>
	</div>

	<script>

// --- Configuration/Storage keys
const STORAGE_IP_KEY = 'slideshow_server_ip';
const STORAGE_PORT_KEY = 'slideshow_server_port';
const STORAGE_DELAY_KEY = 'slideshow_delay_sec';
const STORAGE_LASTID_KEY = 'slideshow_last_id';

// --- Loader timing tweaks
const SHOW_LOADING_MS = 800; // show spinner only after this delay (prevents flash)
const MAX_LOAD_MS = 4000;   // give up this attempt after this many ms

const PORT = 8001;

// --- Elements
const app = document.getElementById('app');
const layerA = document.getElementById('layerA');
const layerB = document.getElementById('layerB');
const pauseOverlay = document.getElementById('pauseOverlay');
const loadingSpinner = document.getElementById('loadingSpinner');
const settingsEl = document.getElementById('settings');
const serverErrorEl = document.getElementById('serverError');
const ipInput = document.getElementById('ipInput');
const portInput = document.getElementById('portInput');
const delayInput = document.getElementById('delayInput');
const saveBtn = document.getElementById('saveBtn');
const cancelBtn = document.getElementById('cancelBtn');
const msgEl = document.getElementById('msg');
const hintEl = document.getElementById('hint');
const UI = document.getElementById('UI');
const likeBtn = document.getElementById('likeBtn');
const excludeBtn = document.getElementById('excludeBtn');
const rotateBtn = document.getElementById('rotateBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

// --- State
let serverIP = '';
let serverPort = 8001;
let delaySec = 5;
let currentId = 0;
let autoTimer = null;
let paused = false;
let visibleLayer = 0;
let pendingLoad = null; // will store {id, attempts, img, showTimer, maxTimer, deadline}

function saveSettings(ip, port, delay) {
	localStorage.setItem(STORAGE_IP_KEY, ip);
	localStorage.setItem(STORAGE_PORT_KEY, port);
	localStorage.setItem(STORAGE_DELAY_KEY, String(delay));
}
function loadSettings() {
	return {
		ip: localStorage.getItem(STORAGE_IP_KEY) || '',
		port: localStorage.getItem(STORAGE_PORT_KEY) || '',
		delay: parseInt(localStorage.getItem(STORAGE_DELAY_KEY),10) || 5
	};
}

function saveLastId(id) { localStorage.setItem(STORAGE_LASTID_KEY, String(id)); }
function loadLastId() { const v = parseInt(localStorage.getItem(STORAGE_LASTID_KEY),10); return Number.isFinite(v) ? v : null; }

function showSettings(message) {
	if (message) { serverErrorEl.style.display = 'block'; serverErrorEl.textContent = message; }
	else { serverErrorEl.style.display = 'none'; }
	const s = loadSettings();
	if (!ipInput.value) ipInput.value = s.ip || '192.168.2.33';
	if (!portInput.value) portInput.value = s.port || '8001';
	delayInput.value = s.delay || 5;
	settingsEl.classList.remove('hidden');
	paused = true; updatePauseUI();
	app.focus();
}
function hideSettings() { settingsEl.classList.add('hidden'); serverErrorEl.style.display='none'; }

function updateMessage(t) { msgEl.textContent = t; }

function updatePauseUI() {
	if (paused) {
		pauseOverlay.classList.add('visible');
		hintEl.style.display = 'block';
	} else {
		pauseOverlay.classList.remove('visible');
		hintEl.style.display = 'none';
	}
}

function buildImageUrl(id) {
	return `http://${serverIP}:${serverPort}/image/${id}`;
}

function setVisibleBackground(layerEl, url) {
	layerEl.style.backgroundImage = `url("${url}")`;
	resetRotation(layerEl);
}

function swapToLayer(n, quick, instant = false) {
	if (instant) {
		layerA.style.transition = 'none';
		layerB.style.transition = 'none';
	} else {
		var tr = `opacity ${quick ? 200 : 800}ms ease`;
		layerA.style.transition = tr;
		layerB.style.transition = tr;
	}
	
	if (n===0) {
		layerA.classList.add('visible');
		layerB.classList.remove('visible');
		visibleLayer = 0;
	}
	else {
		layerB.classList.add('visible');
		layerA.classList.remove('visible');
		visibleLayer = 1;
	}
	
	if (instant) {
		setTimeout(() => {
			layerA.style.transition = '';
			layerB.style.transition = '';
		}, 50);
	}
}

function showImmediateImage(id, quick, instant) {
	// load and display immediately (used for manual next/prev)
	attemptLoadAndShow(id, /*deadlineMs*/ Date.now() + (delaySec*1000) - 200, /*allowFallbackToSettings*/ true, quick, instant);
}

function clearPendingTimers(pl) {
	if (!pl) return;
	if (pl.showTimer) {
		clearTimeout(pl.showTimer);
		pl.showTimer = null;
	}
	if (pl.maxTimer) {
		clearTimeout(pl.maxTimer);
		pl.maxTimer = null;
	}
}

function hideSpinnerAndClearPending() {
	loadingSpinner.classList.remove('visible');
	// clear pendingLoad timers if any
	if (pendingLoad) {
		clearPendingTimers(pendingLoad);
		pendingLoad = null;
	}
}

function attemptLoadAndShow(id, deadlineMs, allowFallbackToSettings, quick, instant = false) {
	// cancel previous pending attempt
	if (pendingLoad && pendingLoad.img) {
		pendingLoad.img.onload = pendingLoad.img.onerror = null;
		clearPendingTimers(pendingLoad);
	}
	pendingLoad = { id, attempts:0, img: null, deadline: deadlineMs, showTimer: null, maxTimer: null };

	const tryLoad = () => {
		// if deadline already passed, abort
		if (Date.now() > pendingLoad.deadline) {
			clearPendingTimers(pendingLoad);
			pendingLoad = null;
			loadingSpinner.classList.remove('visible');
			updateMessage('');
			return false;
		}
		pendingLoad.attempts++;
		const img = new Image(); pendingLoad.img = img;
		let completed = false;

		// schedule spinner to appear only after SHOW_LOADING_MS
		pendingLoad.showTimer = setTimeout(()=>{
			loadingSpinner.classList.add('visible');
			pendingLoad.showTimer = null;
		}, SHOW_LOADING_MS);

		// enforce a hard max timeout for this attempt
		const remainingForMax = Math.min(MAX_LOAD_MS, Math.max(0, pendingLoad.deadline - Date.now()));
		pendingLoad.maxTimer = setTimeout(()=>{
			if (completed) return;
			completed = true;
			// stop load
			try { img.onload = img.onerror = null; } catch(e){}
			loadingSpinner.classList.remove('visible');
			clearPendingTimers(pendingLoad);
			pendingLoad = null;
			updateMessage('');
			if (allowFallbackToSettings) { showSettings('Server not responding'); }
		}, remainingForMax);

		img.onload = () => {
			if (completed) return;
			completed = true;
			// success: clear timers and show
			clearPendingTimers(pendingLoad);
			loadingSpinner.classList.remove('visible');
			pendingLoad.img = null;
			const url = buildImageUrl(id);
			const inactiveLayer = (visibleLayer===0)?layerB:layerA;
			setVisibleBackground(inactiveLayer, url);
			requestAnimationFrame(()=>{
				swapToLayer((visibleLayer===0)?1:0, quick, instant);
			});
			currentId = id; saveLastId(currentId);
			pendingLoad = null;
			updateMessage('');
		};
		img.onerror = () => {
			if (completed) return;
			completed = true;
			// failed this attempt
			clearPendingTimers(pendingLoad);
			loadingSpinner.classList.remove('visible');
			pendingLoad = null;
			updateMessage('');
			// retry once quickly if within deadline
			if (pendingLoad === null && Date.now() < deadlineMs && pendingLoad?.attempts < 2) {
				/* unreachable because we cleared pendingLoad; keep logic simple by retrying directly */
			}
			// If first load (startup) failed and fallback allowed, open settings
			if (allowFallbackToSettings) { showSettings('Server not responding'); }
		};
		// append cache-busting on retries
		const src = buildImageUrl(id) + (pendingLoad.attempts>1?('?r='+Date.now()):'');
		img.src = src;
		return true;
	};

	// Start the first try immediately
	tryLoad();
}

function startAutoTimer() {
	stopAutoTimer();
	autoTimer = setInterval(()=>{
		if (paused) return; // shouldn't occur but safe
		const nextId = currentId + 1;
		const deadline = Date.now() + (delaySec*1000) - 200;
		// attempt to load and show; if it doesn't load before deadline it'll give up
		attemptLoadAndShow(nextId, deadline, /*allowFallbackToSettings*/ false, false, false);
	}, delaySec*1000);
}
function stopAutoTimer() { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; } }

function togglePause() {
	paused = !paused;
	updatePauseUI();
	if (paused) {
		stopAutoTimer();
		showSettings();
	} else {
		hideSettings();
		startAutoTimer();
	}
}

// Remote/back/keyboard handling
function tryExitApp() {
	// Try common TV app exit methods; not guaranteed for all environments
	try {
		if (typeof tizen !== 'undefined' && tizen.application && tizen.application.getCurrentApplication) {
			tizen.application.getCurrentApplication().exit();
			return;
		}
	} catch(e) {}
	try {
		if (typeof webOS !== 'undefined' && webOS.platformBack) {
			webOS.platformBack();
			return;
		}
	} catch(e) {}
	try {
		window.close();
	} catch(e) {}
	// fallback: navigate to about:blank
	document.location.href = 'about:blank';
}

document.addEventListener('mousemove', showButtons);
function onKey(e) {
	const code = e.keyCode || e.which;
	// Left: 37, Right:39, Enter:13, Return/Back: 8,27,10009,461
	if ([37, 39, 13].includes(code)) {
		showButtons();
	}
	
	if (code === 37) { // left
		e.preventDefault(); prevPhoto(true);
	} else if (code === 39) { // right
		e.preventDefault(); nextPhoto(true);
	} else if (code === 13) { // enter/ok
		e.preventDefault(); // toggle pause / settings
		if (paused) { paused=false; hideSettings(); startAutoTimer(); updatePauseUI(); }
		else { paused=true; updatePauseUI(); showSettings(); }
	} else if ([27,10009,461].includes(code)) {
		// back/return
		e.preventDefault(); // if settings visible hide it; otherwise exit
		if (!settingsEl.classList.contains('hidden')) {
			hideSettings(); paused=false; updatePauseUI(); // resume
			startAutoTimer();
		} else {
			tryExitApp();
		}
	}
}

function nextPhoto(quick, instant) {
	const id = currentId + 1;
	attemptLoadAndShow(id, Date.now() + (delaySec*1000) - 200, true, quick, instant);
	// reset auto timer when manually navigating
	if (!paused) {
		startAutoTimer();
	}
}
function prevPhoto(quick) {
	const id = currentId - 1;
	showImmediateImage(id, quick, false);
	// reset auto timer when manually navigating
	if (!paused) {
		startAutoTimer();
	}
}

// --- Initial startup flow
function pingServerAndStart(onOk, onFail) {
	const probeId = 1;
	const testImg = new Image();
	let done=false;
	const timeout = setTimeout(()=>{
		if (done) return;
		done=true;
		testImg.onload=testImg.onerror=null;
		onFail();
	}, 3000);
	testImg.onload = ()=>{
		if (done) return;
		done=true;
		clearTimeout(timeout);
		testImg.onload=testImg.onerror=null;
		onOk();
	};
	testImg.onerror = ()=>{
		if (done) return;
		done=true;
		clearTimeout(timeout);
		testImg.onload=testImg.onerror=null;
		onFail();
	};
	testImg.src = buildImageUrl(probeId) + '?r=' + Date.now();
}

function setIPSetting(ip) {
	serverIP = (ip || '').trim();
}

function setPortSetting(port) {
	serverPort = (port || '').trim();
}

function setDelaySetting(delay) {
	delaySec = Math.max(1, Math.floor(delay));
}

function startSlideshow() {
	// if we have a stored last id use it, else random start
	const last = loadLastId();
	if (last !== null) currentId = last;
	else currentId = Math.floor(Math.random()*10000) + 1;
	// attempt to preload initial image and if success start timer
	attemptLoadAndShow(currentId, Date.now() + (delaySec*1000) - 200, /*allowFallbackToSettings*/ true, false, false);
	startAutoTimer();
}

// --- Show feedback buttons on remote movement (arrow keys)
let feedbackHideTimer = null;
function showButtons() {
	UI.classList.add('visible'); // fade in
	clearTimeout(feedbackHideTimer);
	feedbackHideTimer = setTimeout(() => {
		UI.classList.remove('visible'); // fade out
	}, 3000);
}

function triggerServerAction(action) {
	try {
		var url = `http://${serverIP}:${serverPort}/${action}/${currentId}`;
		fetch(url).catch(()=>{
			// On error?
		});
	}catch(e){}
}

function add90Rotation(layer) {
	let currentRotation = parseInt(layer.dataset.rotation || '0', 10);
	currentRotation = (currentRotation + 90) % 360;
	layer.dataset.rotation = currentRotation;
	layer.style.transform = `rotate(${currentRotation}deg)`;
}

function resetRotation(layer) {
	let currentRotation = 0;
	layer.dataset.rotation = currentRotation;
	layer.style.transform = `rotate(${currentRotation}deg)`;
}

// Bind buttons
likeBtn.addEventListener('click', (e) => {
	e.stopPropagation(); // prevent bubbling to app click handler
	triggerServerAction('like');
});
excludeBtn.addEventListener('click', (e) => {
	e.stopPropagation(); // prevent bubbling to app click handler
	triggerServerAction('ignore');
	nextPhoto(true, true); // instant = true
});
rotateBtn.addEventListener('click', async (e) => {
	e.stopPropagation(); // prevent bubbling
	triggerServerAction('rotate')

	const layer = document.querySelector('.layer.visible');
	if (!layer) return;

	add90Rotation(layer);
});
leftBtn.addEventListener('click', async (e) => {
	e.stopPropagation(); // prevent bubbling
	prevPhoto(true);
});
rightBtn.addEventListener('click', async (e) => {
	e.stopPropagation(); // prevent bubbling
	nextPhoto(true);
});

// --- UI events
saveBtn.addEventListener('click', ()=>{
	setIPSetting(ipInput.value.trim());
	setPortSetting(portInput.value.trim());
	setDelaySetting(parseInt(delayInput.value, 10) || 5);
	updateMessage('Checking server...');
	pingServerAndStart(()=>{
		// ok
		saveSettings(serverIP,serverPort,delaySec);
		hideSettings(); paused=false; updatePauseUI();
		startSlideshow();
		updateMessage('');
	}, ()=>{
		// fail
		updateMessage('');
		showSettings('Server not responding');
	});
});
cancelBtn.addEventListener('click', ()=>{
	if (settingsEl.classList.contains('hidden')) return;
	hideSettings();
	paused=false; updatePauseUI();
	startAutoTimer();
});

// keyboard/remote capture
document.addEventListener('keydown', onKey);

// prevent clicks inside settings from bubbling to the app
settingsEl.addEventListener('click', (e)=>{ e.stopPropagation(); });

// click in screensaver area: open pause/settings (only when settings hidden)
app.addEventListener('click', (e)=>{
	const ignored = e.target.closest('.navBtn, #settings, #feedbackBtns, #rotateBtn');
	if (ignored) return;
	
	if (settingsEl.classList.contains('hidden') &&
		!paused)
	{
		paused = true;
		stopAutoTimer();
		updatePauseUI();
		showSettings();
	}
});

// focus to receive keys
setTimeout(()=>{ app.focus(); },200);

// --- Boot
(function boot() {
	const s = loadSettings();
	if (!s.ip) {
		// no stored ip -> show settings
		showSettings();
		return;
	}
	// we have stored ip; test it
	setIPSetting(s.ip);
	setPortSetting(s.port);
	setDelaySetting(s.delay);
	updateMessage('Checking saved server...');
	pingServerAndStart(()=>{
		updateMessage('');
		startSlideshow();
	}, ()=>{
		updateMessage('');
		showSettings('Server not responding');
	});
})();

	</script>
</body>
</html>